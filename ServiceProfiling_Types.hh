// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for dark (dark@development) on Wed Jun  6 21:29:46 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef ServiceProfiling__Types_HH
#define ServiceProfiling__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef ServiceProfiling__Types_HH
#endif

namespace ServiceProfiling__Types {

/* Forward declarations of classes */

class ResourceConfigurations;
class ResourceConfigurations_template;
class ResourceConfiguration;
class ResourceConfiguration_template;
class MeasuringPointVNFs;
class MeasuringPointVNFs_template;
class MeasuringPointVNF;
class MeasuringPointVNF_template;
class ServiceProfilingExperiment;
class ServiceProfilingExperiment_template;
class Setup__SFC;
class Setup__SFC_template;
class Add__VNF;
class Add__VNF_template;
class Start__CMD;
class Start__CMD_template;
class Start__CMD__reply;
class Start__CMD__reply_template;
class Parameter__Macro;
class Parameter__Macro_template;

} /* end of namespace */

#ifndef ServiceProfiling__Types_HH
#define ServiceProfiling__Types_HH

namespace ServiceProfiling__Types {

/* Class definitions */

class ResourceConfigurations : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ResourceConfiguration **value_elements;
} *val_ptr;

static const ResourceConfiguration UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ResourceConfigurations& other_value);

public:
  typedef ResourceConfiguration of_type;
ResourceConfigurations();
ResourceConfigurations(null_type other_value);
ResourceConfigurations(const ResourceConfigurations& other_value);
~ResourceConfigurations();

void clean_up();
ResourceConfigurations& operator=(null_type other_value);
ResourceConfigurations& operator=(const ResourceConfigurations& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ResourceConfigurations& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ResourceConfigurations& other_value) const { return !(*this == other_value); }

ResourceConfiguration& operator[](int index_value);
ResourceConfiguration& operator[](const INTEGER& index_value);
const ResourceConfiguration& operator[](int index_value) const;
const ResourceConfiguration& operator[](const INTEGER& index_value) const;

ResourceConfigurations operator<<=(int rotate_count) const;
ResourceConfigurations operator<<=(const INTEGER& rotate_count) const;
ResourceConfigurations operator>>=(int rotate_count) const;
ResourceConfigurations operator>>=(const INTEGER& rotate_count) const;

ResourceConfigurations operator+(const ResourceConfigurations& other_value) const;

ResourceConfigurations substr(int index, int returncount) const;

ResourceConfigurations replace(int index, int len, const ResourceConfigurations& repl) const;

ResourceConfigurations replace(int index, int len, const ResourceConfigurations_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ResourceConfigurations_template : public Record_Of_Template {
union {
struct {
int n_elements;
ResourceConfiguration_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ResourceConfigurations_template *list_value;
} value_list;
};
void copy_value(const ResourceConfigurations& other_value);
void copy_template(const ResourceConfigurations_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ResourceConfigurations_template();
ResourceConfigurations_template(template_sel other_value);
ResourceConfigurations_template(null_type other_value);
ResourceConfigurations_template(const ResourceConfigurations& other_value);
ResourceConfigurations_template(const OPTIONAL<ResourceConfigurations>& other_value);
ResourceConfigurations_template(const ResourceConfigurations_template& other_value);
~ResourceConfigurations_template();

void clean_up();
ResourceConfigurations_template& operator=(template_sel other_value);
ResourceConfigurations_template& operator=(null_type other_value);
ResourceConfigurations_template& operator=(const ResourceConfigurations& other_value);
ResourceConfigurations_template& operator=(const OPTIONAL<ResourceConfigurations>& other_value);
ResourceConfigurations_template& operator=(const ResourceConfigurations_template& other_value);

ResourceConfiguration_template& operator[](int index_value);
ResourceConfiguration_template& operator[](const INTEGER& index_value);
const ResourceConfiguration_template& operator[](int index_value) const;
const ResourceConfiguration_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ResourceConfigurations& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ResourceConfigurations valueof() const;
ResourceConfigurations substr(int index, int returncount) const;

ResourceConfigurations replace(int index, int len, const ResourceConfigurations_template& repl) const;

ResourceConfigurations replace(int index, int len, const ResourceConfigurations& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ResourceConfigurations_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ResourceConfigurations& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ResourceConfiguration {
  CHARSTRING field_function__id;
  CHARSTRING field_cpu__time;
  CHARSTRING field_cpu__set;
  CHARSTRING field_max__mem;
  OPTIONAL<BOOLEAN> field_sriov;
public:
  ResourceConfiguration();
  ResourceConfiguration(const CHARSTRING& par_function__id,
    const CHARSTRING& par_cpu__time,
    const CHARSTRING& par_cpu__set,
    const CHARSTRING& par_max__mem,
    const OPTIONAL<BOOLEAN>& par_sriov);
  ResourceConfiguration(const ResourceConfiguration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ResourceConfiguration& operator=(const ResourceConfiguration& other_value);
  boolean operator==(const ResourceConfiguration& other_value) const;
  inline boolean operator!=(const ResourceConfiguration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& function__id()
    {return field_function__id;}
  inline const CHARSTRING& function__id() const
    {return field_function__id;}
  inline CHARSTRING& cpu__time()
    {return field_cpu__time;}
  inline const CHARSTRING& cpu__time() const
    {return field_cpu__time;}
  inline CHARSTRING& cpu__set()
    {return field_cpu__set;}
  inline const CHARSTRING& cpu__set() const
    {return field_cpu__set;}
  inline CHARSTRING& max__mem()
    {return field_max__mem;}
  inline const CHARSTRING& max__mem() const
    {return field_max__mem;}
  inline OPTIONAL<BOOLEAN>& sriov()
    {return field_sriov;}
  inline const OPTIONAL<BOOLEAN>& sriov() const
    {return field_sriov;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ResourceConfiguration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ResourceConfiguration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ResourceConfiguration& other_value);
void copy_template(const ResourceConfiguration_template& other_value);

public:
ResourceConfiguration_template();
ResourceConfiguration_template(template_sel other_value);
ResourceConfiguration_template(const ResourceConfiguration& other_value);
ResourceConfiguration_template(const OPTIONAL<ResourceConfiguration>& other_value);
ResourceConfiguration_template(const ResourceConfiguration_template& other_value);
~ResourceConfiguration_template();
ResourceConfiguration_template& operator=(template_sel other_value);
ResourceConfiguration_template& operator=(const ResourceConfiguration& other_value);
ResourceConfiguration_template& operator=(const OPTIONAL<ResourceConfiguration>& other_value);
ResourceConfiguration_template& operator=(const ResourceConfiguration_template& other_value);
boolean match(const ResourceConfiguration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ResourceConfiguration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ResourceConfiguration_template& list_item(unsigned int list_index) const;
CHARSTRING_template& function__id();
const CHARSTRING_template& function__id() const;
CHARSTRING_template& cpu__time();
const CHARSTRING_template& cpu__time() const;
CHARSTRING_template& cpu__set();
const CHARSTRING_template& cpu__set() const;
CHARSTRING_template& max__mem();
const CHARSTRING_template& max__mem() const;
BOOLEAN_template& sriov();
const BOOLEAN_template& sriov() const;
int size_of() const;
void log() const;
void log_match(const ResourceConfiguration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MeasuringPointVNFs : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MeasuringPointVNF **value_elements;
} *val_ptr;

static const MeasuringPointVNF UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MeasuringPointVNFs& other_value);

public:
  typedef MeasuringPointVNF of_type;
MeasuringPointVNFs();
MeasuringPointVNFs(null_type other_value);
MeasuringPointVNFs(const MeasuringPointVNFs& other_value);
~MeasuringPointVNFs();

void clean_up();
MeasuringPointVNFs& operator=(null_type other_value);
MeasuringPointVNFs& operator=(const MeasuringPointVNFs& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MeasuringPointVNFs& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MeasuringPointVNFs& other_value) const { return !(*this == other_value); }

MeasuringPointVNF& operator[](int index_value);
MeasuringPointVNF& operator[](const INTEGER& index_value);
const MeasuringPointVNF& operator[](int index_value) const;
const MeasuringPointVNF& operator[](const INTEGER& index_value) const;

MeasuringPointVNFs operator<<=(int rotate_count) const;
MeasuringPointVNFs operator<<=(const INTEGER& rotate_count) const;
MeasuringPointVNFs operator>>=(int rotate_count) const;
MeasuringPointVNFs operator>>=(const INTEGER& rotate_count) const;

MeasuringPointVNFs operator+(const MeasuringPointVNFs& other_value) const;

MeasuringPointVNFs substr(int index, int returncount) const;

MeasuringPointVNFs replace(int index, int len, const MeasuringPointVNFs& repl) const;

MeasuringPointVNFs replace(int index, int len, const MeasuringPointVNFs_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class MeasuringPointVNFs_template : public Record_Of_Template {
union {
struct {
int n_elements;
MeasuringPointVNF_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MeasuringPointVNFs_template *list_value;
} value_list;
};
void copy_value(const MeasuringPointVNFs& other_value);
void copy_template(const MeasuringPointVNFs_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MeasuringPointVNFs_template();
MeasuringPointVNFs_template(template_sel other_value);
MeasuringPointVNFs_template(null_type other_value);
MeasuringPointVNFs_template(const MeasuringPointVNFs& other_value);
MeasuringPointVNFs_template(const OPTIONAL<MeasuringPointVNFs>& other_value);
MeasuringPointVNFs_template(const MeasuringPointVNFs_template& other_value);
~MeasuringPointVNFs_template();

void clean_up();
MeasuringPointVNFs_template& operator=(template_sel other_value);
MeasuringPointVNFs_template& operator=(null_type other_value);
MeasuringPointVNFs_template& operator=(const MeasuringPointVNFs& other_value);
MeasuringPointVNFs_template& operator=(const OPTIONAL<MeasuringPointVNFs>& other_value);
MeasuringPointVNFs_template& operator=(const MeasuringPointVNFs_template& other_value);

MeasuringPointVNF_template& operator[](int index_value);
MeasuringPointVNF_template& operator[](const INTEGER& index_value);
const MeasuringPointVNF_template& operator[](int index_value) const;
const MeasuringPointVNF_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MeasuringPointVNFs& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MeasuringPointVNFs valueof() const;
MeasuringPointVNFs substr(int index, int returncount) const;

MeasuringPointVNFs replace(int index, int len, const MeasuringPointVNFs_template& repl) const;

MeasuringPointVNFs replace(int index, int len, const MeasuringPointVNFs& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MeasuringPointVNFs_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MeasuringPointVNFs& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MeasuringPointVNF {
  CHARSTRING field_name;
  CHARSTRING field_connection__point;
  CHARSTRING field_image;
  OPTIONAL<CHARSTRING> field_cmd;
public:
  MeasuringPointVNF();
  MeasuringPointVNF(const CHARSTRING& par_name,
    const CHARSTRING& par_connection__point,
    const CHARSTRING& par_image,
    const OPTIONAL<CHARSTRING>& par_cmd);
  MeasuringPointVNF(const MeasuringPointVNF& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MeasuringPointVNF& operator=(const MeasuringPointVNF& other_value);
  boolean operator==(const MeasuringPointVNF& other_value) const;
  inline boolean operator!=(const MeasuringPointVNF& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline CHARSTRING& connection__point()
    {return field_connection__point;}
  inline const CHARSTRING& connection__point() const
    {return field_connection__point;}
  inline CHARSTRING& image()
    {return field_image;}
  inline const CHARSTRING& image() const
    {return field_image;}
  inline OPTIONAL<CHARSTRING>& cmd()
    {return field_cmd;}
  inline const OPTIONAL<CHARSTRING>& cmd() const
    {return field_cmd;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class MeasuringPointVNF_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MeasuringPointVNF_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MeasuringPointVNF& other_value);
void copy_template(const MeasuringPointVNF_template& other_value);

public:
MeasuringPointVNF_template();
MeasuringPointVNF_template(template_sel other_value);
MeasuringPointVNF_template(const MeasuringPointVNF& other_value);
MeasuringPointVNF_template(const OPTIONAL<MeasuringPointVNF>& other_value);
MeasuringPointVNF_template(const MeasuringPointVNF_template& other_value);
~MeasuringPointVNF_template();
MeasuringPointVNF_template& operator=(template_sel other_value);
MeasuringPointVNF_template& operator=(const MeasuringPointVNF& other_value);
MeasuringPointVNF_template& operator=(const OPTIONAL<MeasuringPointVNF>& other_value);
MeasuringPointVNF_template& operator=(const MeasuringPointVNF_template& other_value);
boolean match(const MeasuringPointVNF& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MeasuringPointVNF valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MeasuringPointVNF_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
CHARSTRING_template& connection__point();
const CHARSTRING_template& connection__point() const;
CHARSTRING_template& image();
const CHARSTRING_template& image() const;
CHARSTRING_template& cmd();
const CHARSTRING_template& cmd() const;
int size_of() const;
void log() const;
void log_match(const MeasuringPointVNF& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServiceProfilingExperiment {
  CHARSTRING field_name;
  INTEGER field_repetitions;
  INTEGER field_profiling__timeout;
  CHARSTRING field_service__name;
  ResourceConfigurations field_resourcecfgs;
  MeasuringPointVNFs field_MpVNFs;
public:
  ServiceProfilingExperiment();
  ServiceProfilingExperiment(const CHARSTRING& par_name,
    const INTEGER& par_repetitions,
    const INTEGER& par_profiling__timeout,
    const CHARSTRING& par_service__name,
    const ResourceConfigurations& par_resourcecfgs,
    const MeasuringPointVNFs& par_MpVNFs);
  ServiceProfilingExperiment(const ServiceProfilingExperiment& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServiceProfilingExperiment& operator=(const ServiceProfilingExperiment& other_value);
  boolean operator==(const ServiceProfilingExperiment& other_value) const;
  inline boolean operator!=(const ServiceProfilingExperiment& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline INTEGER& repetitions()
    {return field_repetitions;}
  inline const INTEGER& repetitions() const
    {return field_repetitions;}
  inline INTEGER& profiling__timeout()
    {return field_profiling__timeout;}
  inline const INTEGER& profiling__timeout() const
    {return field_profiling__timeout;}
  inline CHARSTRING& service__name()
    {return field_service__name;}
  inline const CHARSTRING& service__name() const
    {return field_service__name;}
  inline ResourceConfigurations& resourcecfgs()
    {return field_resourcecfgs;}
  inline const ResourceConfigurations& resourcecfgs() const
    {return field_resourcecfgs;}
  inline MeasuringPointVNFs& MpVNFs()
    {return field_MpVNFs;}
  inline const MeasuringPointVNFs& MpVNFs() const
    {return field_MpVNFs;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ServiceProfilingExperiment_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServiceProfilingExperiment_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServiceProfilingExperiment& other_value);
void copy_template(const ServiceProfilingExperiment_template& other_value);

public:
ServiceProfilingExperiment_template();
ServiceProfilingExperiment_template(template_sel other_value);
ServiceProfilingExperiment_template(const ServiceProfilingExperiment& other_value);
ServiceProfilingExperiment_template(const OPTIONAL<ServiceProfilingExperiment>& other_value);
ServiceProfilingExperiment_template(const ServiceProfilingExperiment_template& other_value);
~ServiceProfilingExperiment_template();
ServiceProfilingExperiment_template& operator=(template_sel other_value);
ServiceProfilingExperiment_template& operator=(const ServiceProfilingExperiment& other_value);
ServiceProfilingExperiment_template& operator=(const OPTIONAL<ServiceProfilingExperiment>& other_value);
ServiceProfilingExperiment_template& operator=(const ServiceProfilingExperiment_template& other_value);
boolean match(const ServiceProfilingExperiment& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServiceProfilingExperiment valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServiceProfilingExperiment_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& repetitions();
const INTEGER_template& repetitions() const;
INTEGER_template& profiling__timeout();
const INTEGER_template& profiling__timeout() const;
CHARSTRING_template& service__name();
const CHARSTRING_template& service__name() const;
ResourceConfigurations_template& resourcecfgs();
const ResourceConfigurations_template& resourcecfgs() const;
MeasuringPointVNFs_template& MpVNFs();
const MeasuringPointVNFs_template& MpVNFs() const;
int size_of() const;
void log() const;
void log_match(const ServiceProfilingExperiment& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Setup__SFC {
  CHARSTRING field_service__name;
public:
  Setup__SFC();
  Setup__SFC(const CHARSTRING& par_service__name);
  Setup__SFC(const Setup__SFC& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Setup__SFC& operator=(const Setup__SFC& other_value);
  boolean operator==(const Setup__SFC& other_value) const;
  inline boolean operator!=(const Setup__SFC& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& service__name()
    {return field_service__name;}
  inline const CHARSTRING& service__name() const
    {return field_service__name;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Setup__SFC_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Setup__SFC_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Setup__SFC& other_value);
void copy_template(const Setup__SFC_template& other_value);

public:
Setup__SFC_template();
Setup__SFC_template(template_sel other_value);
Setup__SFC_template(const Setup__SFC& other_value);
Setup__SFC_template(const OPTIONAL<Setup__SFC>& other_value);
Setup__SFC_template(const Setup__SFC_template& other_value);
~Setup__SFC_template();
Setup__SFC_template& operator=(template_sel other_value);
Setup__SFC_template& operator=(const Setup__SFC& other_value);
Setup__SFC_template& operator=(const OPTIONAL<Setup__SFC>& other_value);
Setup__SFC_template& operator=(const Setup__SFC_template& other_value);
boolean match(const Setup__SFC& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Setup__SFC valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Setup__SFC_template& list_item(unsigned int list_index) const;
CHARSTRING_template& service__name();
const CHARSTRING_template& service__name() const;
int size_of() const;
void log() const;
void log_match(const Setup__SFC& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Add__VNF {
  CHARSTRING field_name;
  CHARSTRING field_connection__point;
  CHARSTRING field_image;
public:
  Add__VNF();
  Add__VNF(const CHARSTRING& par_name,
    const CHARSTRING& par_connection__point,
    const CHARSTRING& par_image);
  Add__VNF(const Add__VNF& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Add__VNF& operator=(const Add__VNF& other_value);
  boolean operator==(const Add__VNF& other_value) const;
  inline boolean operator!=(const Add__VNF& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline CHARSTRING& connection__point()
    {return field_connection__point;}
  inline const CHARSTRING& connection__point() const
    {return field_connection__point;}
  inline CHARSTRING& image()
    {return field_image;}
  inline const CHARSTRING& image() const
    {return field_image;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Add__VNF_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Add__VNF_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Add__VNF& other_value);
void copy_template(const Add__VNF_template& other_value);

public:
Add__VNF_template();
Add__VNF_template(template_sel other_value);
Add__VNF_template(const Add__VNF& other_value);
Add__VNF_template(const OPTIONAL<Add__VNF>& other_value);
Add__VNF_template(const Add__VNF_template& other_value);
~Add__VNF_template();
Add__VNF_template& operator=(template_sel other_value);
Add__VNF_template& operator=(const Add__VNF& other_value);
Add__VNF_template& operator=(const OPTIONAL<Add__VNF>& other_value);
Add__VNF_template& operator=(const Add__VNF_template& other_value);
boolean match(const Add__VNF& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Add__VNF valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Add__VNF_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
CHARSTRING_template& connection__point();
const CHARSTRING_template& connection__point() const;
CHARSTRING_template& image();
const CHARSTRING_template& image() const;
int size_of() const;
void log() const;
void log_match(const Add__VNF& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Start__CMD {
  CHARSTRING field_cmd;
public:
  Start__CMD();
  Start__CMD(const CHARSTRING& par_cmd);
  Start__CMD(const Start__CMD& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Start__CMD& operator=(const Start__CMD& other_value);
  boolean operator==(const Start__CMD& other_value) const;
  inline boolean operator!=(const Start__CMD& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& cmd()
    {return field_cmd;}
  inline const CHARSTRING& cmd() const
    {return field_cmd;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Start__CMD_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Start__CMD_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Start__CMD& other_value);
void copy_template(const Start__CMD_template& other_value);

public:
Start__CMD_template();
Start__CMD_template(template_sel other_value);
Start__CMD_template(const Start__CMD& other_value);
Start__CMD_template(const OPTIONAL<Start__CMD>& other_value);
Start__CMD_template(const Start__CMD_template& other_value);
~Start__CMD_template();
Start__CMD_template& operator=(template_sel other_value);
Start__CMD_template& operator=(const Start__CMD& other_value);
Start__CMD_template& operator=(const OPTIONAL<Start__CMD>& other_value);
Start__CMD_template& operator=(const Start__CMD_template& other_value);
boolean match(const Start__CMD& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Start__CMD valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Start__CMD_template& list_item(unsigned int list_index) const;
CHARSTRING_template& cmd();
const CHARSTRING_template& cmd() const;
int size_of() const;
void log() const;
void log_match(const Start__CMD& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Start__CMD__reply {
  CHARSTRING field_cmd__reply;
public:
  Start__CMD__reply();
  Start__CMD__reply(const CHARSTRING& par_cmd__reply);
  Start__CMD__reply(const Start__CMD__reply& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Start__CMD__reply& operator=(const Start__CMD__reply& other_value);
  boolean operator==(const Start__CMD__reply& other_value) const;
  inline boolean operator!=(const Start__CMD__reply& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& cmd__reply()
    {return field_cmd__reply;}
  inline const CHARSTRING& cmd__reply() const
    {return field_cmd__reply;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Start__CMD__reply_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Start__CMD__reply_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Start__CMD__reply& other_value);
void copy_template(const Start__CMD__reply_template& other_value);

public:
Start__CMD__reply_template();
Start__CMD__reply_template(template_sel other_value);
Start__CMD__reply_template(const Start__CMD__reply& other_value);
Start__CMD__reply_template(const OPTIONAL<Start__CMD__reply>& other_value);
Start__CMD__reply_template(const Start__CMD__reply_template& other_value);
~Start__CMD__reply_template();
Start__CMD__reply_template& operator=(template_sel other_value);
Start__CMD__reply_template& operator=(const Start__CMD__reply& other_value);
Start__CMD__reply_template& operator=(const OPTIONAL<Start__CMD__reply>& other_value);
Start__CMD__reply_template& operator=(const Start__CMD__reply_template& other_value);
boolean match(const Start__CMD__reply& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Start__CMD__reply valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Start__CMD__reply_template& list_item(unsigned int list_index) const;
CHARSTRING_template& cmd__reply();
const CHARSTRING_template& cmd__reply() const;
int size_of() const;
void log() const;
void log_match(const Start__CMD__reply& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Parameter__Macro {
  FLOAT field_beginning;
  FLOAT field_end;
  FLOAT field_step;
public:
  Parameter__Macro();
  Parameter__Macro(const FLOAT& par_beginning,
    const FLOAT& par_end,
    const FLOAT& par_step);
  Parameter__Macro(const Parameter__Macro& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Parameter__Macro& operator=(const Parameter__Macro& other_value);
  boolean operator==(const Parameter__Macro& other_value) const;
  inline boolean operator!=(const Parameter__Macro& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline FLOAT& beginning()
    {return field_beginning;}
  inline const FLOAT& beginning() const
    {return field_beginning;}
  inline FLOAT& end()
    {return field_end;}
  inline const FLOAT& end() const
    {return field_end;}
  inline FLOAT& step()
    {return field_step;}
  inline const FLOAT& step() const
    {return field_step;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Parameter__Macro_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Parameter__Macro_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Parameter__Macro& other_value);
void copy_template(const Parameter__Macro_template& other_value);

public:
Parameter__Macro_template();
Parameter__Macro_template(template_sel other_value);
Parameter__Macro_template(const Parameter__Macro& other_value);
Parameter__Macro_template(const OPTIONAL<Parameter__Macro>& other_value);
Parameter__Macro_template(const Parameter__Macro_template& other_value);
~Parameter__Macro_template();
Parameter__Macro_template& operator=(template_sel other_value);
Parameter__Macro_template& operator=(const Parameter__Macro& other_value);
Parameter__Macro_template& operator=(const OPTIONAL<Parameter__Macro>& other_value);
Parameter__Macro_template& operator=(const Parameter__Macro_template& other_value);
boolean match(const Parameter__Macro& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Parameter__Macro valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Parameter__Macro_template& list_item(unsigned int list_index) const;
FLOAT_template& beginning();
const FLOAT_template& beginning() const;
FLOAT_template& end();
const FLOAT_template& end() const;
FLOAT_template& step();
const FLOAT_template& step() const;
int size_of() const;
void log() const;
void log_match(const Parameter__Macro& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const ResourceConfigurations& other_value);
inline boolean operator!=(null_type null_value, const ResourceConfigurations& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MeasuringPointVNFs& other_value);
inline boolean operator!=(null_type null_value, const MeasuringPointVNFs& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t ServiceProfilingExperiment_name_xer_;
extern const TTCN_JSONdescriptor_t ServiceProfilingExperiment_name_json_;
extern const TTCN_Typedescriptor_t ServiceProfilingExperiment_name_descr_;
extern const XERdescriptor_t ServiceProfilingExperiment_repetitions_xer_;
extern const TTCN_JSONdescriptor_t ServiceProfilingExperiment_repetitions_json_;
extern const TTCN_Typedescriptor_t ServiceProfilingExperiment_repetitions_descr_;
extern const XERdescriptor_t ServiceProfilingExperiment_profiling__timeout_xer_;
extern const TTCN_JSONdescriptor_t ServiceProfilingExperiment_profiling__timeout_json_;
extern const TTCN_Typedescriptor_t ServiceProfilingExperiment_profiling__timeout_descr_;
extern const XERdescriptor_t ServiceProfilingExperiment_service__name_xer_;
extern const TTCN_JSONdescriptor_t ServiceProfilingExperiment_service__name_json_;
extern const TTCN_Typedescriptor_t ServiceProfilingExperiment_service__name_descr_;
extern const TTCN_Typedescriptor_t ResourceConfigurations_descr_;
extern const XERdescriptor_t ResourceConfiguration_function__id_xer_;
extern const TTCN_JSONdescriptor_t ResourceConfiguration_function__id_json_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_function__id_descr_;
extern const XERdescriptor_t ResourceConfiguration_cpu__time_xer_;
extern const TTCN_JSONdescriptor_t ResourceConfiguration_cpu__time_json_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_cpu__time_descr_;
extern const XERdescriptor_t ResourceConfiguration_cpu__set_xer_;
extern const TTCN_JSONdescriptor_t ResourceConfiguration_cpu__set_json_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_cpu__set_descr_;
extern const XERdescriptor_t ResourceConfiguration_max__mem_xer_;
extern const TTCN_JSONdescriptor_t ResourceConfiguration_max__mem_json_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_max__mem_descr_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_descr_;
extern const XERdescriptor_t ResourceConfiguration_sriov_xer_;
extern const TTCN_JSONdescriptor_t ResourceConfiguration_sriov_json_;
extern const TTCN_OERdescriptor_t ResourceConfiguration_sriov_oer_;
extern const TTCN_Typedescriptor_t ResourceConfiguration_sriov_descr_;
extern const TTCN_Typedescriptor_t MeasuringPointVNFs_descr_;
extern const XERdescriptor_t MeasuringPointVNF_name_xer_;
extern const TTCN_JSONdescriptor_t MeasuringPointVNF_name_json_;
extern const TTCN_Typedescriptor_t MeasuringPointVNF_name_descr_;
extern const XERdescriptor_t MeasuringPointVNF_connection__point_xer_;
extern const TTCN_JSONdescriptor_t MeasuringPointVNF_connection__point_json_;
extern const TTCN_Typedescriptor_t MeasuringPointVNF_connection__point_descr_;
extern const XERdescriptor_t MeasuringPointVNF_image_xer_;
extern const TTCN_JSONdescriptor_t MeasuringPointVNF_image_json_;
extern const TTCN_Typedescriptor_t MeasuringPointVNF_image_descr_;
extern const TTCN_Typedescriptor_t MeasuringPointVNF_descr_;
extern const XERdescriptor_t MeasuringPointVNF_cmd_xer_;
extern const TTCN_JSONdescriptor_t MeasuringPointVNF_cmd_json_;
extern const TTCN_Typedescriptor_t MeasuringPointVNF_cmd_descr_;
extern const TTCN_Typedescriptor_t ServiceProfilingExperiment_descr_;
extern const XERdescriptor_t Setup__SFC_service__name_xer_;
extern const TTCN_JSONdescriptor_t Setup__SFC_service__name_json_;
extern const TTCN_Typedescriptor_t Setup__SFC_service__name_descr_;
extern const TTCN_Typedescriptor_t Setup__SFC_descr_;
extern const XERdescriptor_t Add__VNF_name_xer_;
extern const TTCN_JSONdescriptor_t Add__VNF_name_json_;
extern const TTCN_Typedescriptor_t Add__VNF_name_descr_;
extern const XERdescriptor_t Add__VNF_connection__point_xer_;
extern const TTCN_JSONdescriptor_t Add__VNF_connection__point_json_;
extern const TTCN_Typedescriptor_t Add__VNF_connection__point_descr_;
extern const XERdescriptor_t Add__VNF_image_xer_;
extern const TTCN_JSONdescriptor_t Add__VNF_image_json_;
extern const TTCN_Typedescriptor_t Add__VNF_image_descr_;
extern const TTCN_Typedescriptor_t Add__VNF_descr_;
extern const XERdescriptor_t Start__CMD_cmd_xer_;
extern const TTCN_JSONdescriptor_t Start__CMD_cmd_json_;
extern const TTCN_Typedescriptor_t Start__CMD_cmd_descr_;
extern const TTCN_Typedescriptor_t Start__CMD_descr_;
extern const XERdescriptor_t Start__CMD__reply_cmd__reply_xer_;
extern const TTCN_JSONdescriptor_t Start__CMD__reply_cmd__reply_json_;
extern const TTCN_Typedescriptor_t Start__CMD__reply_cmd__reply_descr_;
extern const TTCN_Typedescriptor_t Start__CMD__reply_descr_;
extern const XERdescriptor_t Parameter__Macro_beginning_xer_;
extern const TTCN_JSONdescriptor_t Parameter__Macro_beginning_json_;
extern const TTCN_OERdescriptor_t Parameter__Macro_beginning_oer_;
extern const TTCN_Typedescriptor_t Parameter__Macro_beginning_descr_;
extern const XERdescriptor_t Parameter__Macro_end_xer_;
extern const TTCN_JSONdescriptor_t Parameter__Macro_end_json_;
extern const TTCN_OERdescriptor_t Parameter__Macro_end_oer_;
extern const TTCN_Typedescriptor_t Parameter__Macro_end_descr_;
extern const XERdescriptor_t Parameter__Macro_step_xer_;
extern const TTCN_JSONdescriptor_t Parameter__Macro_step_json_;
extern const TTCN_OERdescriptor_t Parameter__Macro_step_oer_;
extern const TTCN_Typedescriptor_t Parameter__Macro_step_descr_;
extern const TTCN_Typedescriptor_t Parameter__Macro_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
