// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for dark (dark@development) on Wed May 23 15:46:39 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "ManoMsg.hh"
#include <curl/curl.h>
#include <json/json.h>
#include "yaml-cpp/yaml.h" // yaml-cpp >=0.6 needed
#include <iostream>
#include <string>
#include <fstream>
#include <streambuf>
#include <cstdlib>
#include <boost/algorithm/string.hpp>
#include <chrono>
#include <thread>
#include <cpprest/http_client.h>
#include <cpprest/filestream.h>


namespace ServiceProfiling__PortType {

ManoMsg::ManoMsg(const char *par_port_name)
	: ManoMsg_BASE(par_port_name)
{
	debug = true;
	debug_http = true;

	//vnf_path = "/home/dark/son-examples/service-projects/sonata-empty-service-emu/sources/vnf/";
	nsd_path = "/home/dark/son-examples/service-projects/";

	gatekeeper_rest_url = "http://172.17.0.2:5000";
	vimemu_rest_url = "http://172.17.0.2:5001";
	rest_username = "admin";
	rest_password = "admin";

	//sfc_service_instance_uuid = "";
	//sfc_service_uuid = "";
}

ManoMsg::~ManoMsg()
{

}

void ManoMsg::set_parameter(const char * /*parameter_name*/,
	const char * /*parameter_value*/)
{

}

/*void ManoMsg::Handle_Fd_Event(int fd, boolean is_readable,
	boolean is_writable, boolean is_error) {}*/

void ManoMsg::Handle_Fd_Event_Error(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Writable(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Readable(int /*fd*/)
{

}

/*void ManoMsg::Handle_Timeout(double time_since_last_call) {}*/

void ManoMsg::user_map(const char * /*system_port*/)
{
	startDockerContainer();

	//setupCurl();

	int retries = 5;
	while(!performRestRequest(gatekeeper_rest_url + "/instantiations")) {
		if(retries <= 0) {
			TTCN_error("Could connect to vim-emu!");
		} else {
			log("Retrying request");
		}

		// wait 2 seconds if the request did not work
		std::this_thread::sleep_for(std::chrono::milliseconds(4000));

		retries--;
	}

	//cleanCurl();
}

void ManoMsg::user_unmap(const char * /*system_port*/)
{
	stopAllVNF();

	if(!sfc_service_instance_uuid.empty() && !sfc_service_uuid.empty()) {
		stopSfcService(sfc_service_uuid, sfc_service_instance_uuid);
	}

	stopDockerContainer();
}

void ManoMsg::user_start()
{

}

void ManoMsg::user_stop()
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Setup__SFC& send_par)
{
	if(!sfc_service_instance_uuid.empty() && !sfc_service_uuid.empty()) {
		stopSfcService(sfc_service_uuid, sfc_service_instance_uuid);
	}

	std::string service_name = std::string(((const char*)send_par.service__name()));
	std::string filepath = nsd_path + service_name;

	log("Create SFC from %s", filepath.c_str());

	sfc_service_uuid = uploadPackage(filepath);
	sfc_service_instance_uuid = startSfcService(sfc_service_uuid);

	log("SFC created and running");
}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Add__VNF& send_par)
{
	std::string vnf_name = std::string(((const char*)send_par.name()));
	std::string vnf_cp = std::string(((const char*)send_par.connection__point()));
	std::string vnf_image = std::string(((const char*)send_par.image()));

	log("Setting up VNF %s with connection point %s from image %s", vnf_name.c_str(), vnf_cp.c_str(), vnf_image.c_str());

	startVNF(vnf_name, vnf_image);
	connectVnfToSfc(vnf_name, vnf_cp);
}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Start__CMD& /*send_par*/)
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::ResourceConfiguration& send_par)
{
	std::string vnf_name = std::string(((const char*)send_par.function__id()));
	std::string memory_size = std::string(((const char*)send_par.max__mem()));
	std::string cpu_set = std::string(((const char*)send_par.cpu__set()));

	log("Setting resource configuration of VNF %s", vnf_name.c_str());

	// TODO: filename
	//std::string filename = nsd_path  + "sonata-empty-service-emu" + "/sources/vnf/" + vnf_name + "-vnfd.yml";
	std::string filename = "/home/dark/son-examples/service-projects/sonata-snort-service-emu/sources/vnf/snort-vnf/snort-vnfd.yml";

	log("Filename %s", filename.c_str());

	//YAML::Node root(YAML::LoadFile(filename));

	YAML::Node file = YAML::LoadFile(filename);

	file["virtual_deployment_units"][0]["resource_requirements"]["cpu"]["vcpus"] = 2; // TODO
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size"] = memory_size;
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size"] = "\"512\""; // TODO
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size_unit"] = "\"MB\"";

	// Save the values as double qouted strings to the file
	std::ofstream fout(filename);
	YAML::Emitter em(fout);
	em.SetIndent(2);
	//em << file;


	//std::ofstream fout(filename);
	//fout << file;

	//std::system("son-package --project sonata-snort-service-emu -n sonata-snort-service");

	log("Setting resource configuration of VNF %s completed", vnf_name.c_str());
}

size_t ManoMsg::replyToMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

bool ManoMsg::performRestRequest(std::string url) {
	bool sucessfull = true;
	log("Perform request to %s.", url.c_str());

	curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

	/* We have to overwrite the last reply or the new reply from the server will be appended to the previous reply */
	replyBuffer = "";

	res = curl_easy_perform(curl);
	log("replyBuffer: %s", replyBuffer.c_str());
	if(res != CURLE_OK) {
		//long response_code;
		//curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
		//TTCN_error("curl_easy_perform() failed with http code %ld: %s\n", response_code, curl_easy_strerror(res));
		sucessfull = false;
	}

	log("End perform request");

	return sucessfull;
}

void ManoMsg::log(const char *fmt, ...) {
	if (debug) {
		va_list ap;
		va_start(ap, fmt);
		TTCN_Logger::begin_event(TTCN_DEBUG);
		TTCN_Logger::log_event("ManoMsg Test Port (%s): ", get_name());
		TTCN_Logger::log_event_va_list(fmt, ap);
		TTCN_Logger::end_event();
		va_end(ap);
	}
}

std::string ManoMsg::uploadPackage(std::string filepath) {
	log("Upload package from %s", filepath.c_str());

	setupCurl();

	curl_mime *mime = curl_mime_init(curl);
	curl_mimepart *part = curl_mime_addpart(mime);
	curl_mime_filedata(part, filepath.c_str());
	curl_mime_name(part, "package");

	curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);
	performRestRequest(gatekeeper_rest_url + "/packages");
	curl_mime_free(mime);
	cleanCurl();

	std::string service_uuid = getJsonValueFromReply("service_uuid");
	return service_uuid;
}

std::string ManoMsg::startSfcService(std::string service_uuid) {
	log("Start service with uuid %s", service_uuid.c_str());

	Json::Value request;
	request["service_uuid"] = service_uuid;
	std::string document = getJsonDocument(request);

	setupCurl();
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, document.c_str());
	performRestRequest(gatekeeper_rest_url + "/instantiations");
	cleanCurl();

	std::string service_instance_uuid = getJsonValueFromReply("service_instance_uuid");
	return service_instance_uuid;
}


void ManoMsg::stopSfcService(std::string service_uuid, std::string service_instance_uuid) {
	log("Stop service with uuid %s and instance uuid %s", service_uuid.c_str(), service_instance_uuid.c_str());

	Json::Value request;
	request["service_uuid"] = service_uuid;
	request["service_instance_uuid"] = service_instance_uuid;
	std::string document = getJsonDocument(request);
	log("Request: %s", document.c_str());

	setupCurl();
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, document.c_str());
	performRestRequest(gatekeeper_rest_url + "/instantiations");
	cleanCurl();

	log("Stopped service");
}

void ManoMsg::startVNF(std::string vnf_name, std::string vnf_image) {
	log("Start measurement point VNF with name %s from image %s", vnf_name.c_str(), vnf_image.c_str());

	Json::Value request_vnf;
	request_vnf["image"] = vnf_image;
	std::string document_vnf = getJsonDocument(request_vnf);

	setupCurl();
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, document_vnf.c_str());
	performRestRequest(vimemu_rest_url + "/restapi/compute/" + "dc1/" + vnf_name); // TODO: dc1 configureable
	cleanCurl();

	running_vnfs.push_back(vnf_name);

	log("Measurement point VNF %s created", vnf_name.c_str());
}

void ManoMsg::stopAllVNF() {
	log("Stopping all measurement point VNFs");

	for(std::string vnf_name : running_vnfs) {
		stopVNF(vnf_name);
	}

	running_vnfs.clear();
}

void ManoMsg::stopVNF(std::string vnf_name) {
	log("Stopping measurement point VNF %s", vnf_name.c_str());

	setupCurl();
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
	performRestRequest(vimemu_rest_url + "/restapi/compute/" + "dc1/" + vnf_name); // TODO: dc1 configureable
	cleanCurl();

	log("Measurement point VNF %s stopped", vnf_name.c_str());
}

void ManoMsg::connectVnfToSfc(std::string vnf_name, std::string vnf_cp) {
	log("Connect %s to connection point %s", vnf_name.c_str(), vnf_cp.c_str());

	// TODO: Remove boost dependency (split function)
	std::vector<std::string> vnf_cp_elements;
	boost::split(vnf_cp_elements, vnf_cp, boost::is_any_of(":"));

	Json::Value request_net;
	request_net["vnf_src_name"] = vnf_name; // + ":" + vnf_name + "-eth0";
	request_net["vnf_dst_name"] = vnf_cp_elements[0];
	request_net["vnf_src_interface"] = vnf_name + "-eth0";
	request_net["vnf_dst_interface"] = vnf_cp_elements[1];
	request_net["bidirectional"] = "True";
	request_net["cookie"] = "10";
	request_net["priority"] = "1000";

	///restapi/network?priority=1000&bidirectional=True&cookie=10&vnf_src_name=client&vnf_dst_name=empty_vnf1

	std::string document_net = getJsonDocument(request_net);

	setupCurl();
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, document_net.c_str());
	performRestRequest(vimemu_rest_url + "/restapi/network");
	cleanCurl();

	log("Connected to connection point");
}

std::string ManoMsg::getJsonValueFromReply(std::string key) {
	Json::Value reply;
	Json::Reader reader;

	bool parseSucessful = reader.parse(replyBuffer.c_str(), reply);
	if(!parseSucessful) {
		TTCN_error("Could not parse reply from MANO system: %s\n", reader.getFormattedErrorMessages().c_str());
	}

	std::string value = reply[key].asString();
	log("Current %s is %s", key.c_str(), value.c_str());

	return value;
}

std::string ManoMsg::getJsonDocument(Json::Value jsonv) {
	Json::StreamWriterBuilder wbuilder;
	std::string document = Json::writeString(wbuilder, jsonv);

	log("JSON Payload: %s", document.c_str());

	return document;
}

void ManoMsg::startDockerContainer() {
	log("Starting docker container");

	std::string cmd = "docker run --name vim-emu -d --rm --privileged --pid='host' -v /var/run/docker.sock:/var/run/docker.sock vim-emu-img > /dev/null";
	int status = std::system(cmd.c_str());

	if(status < 0) {
		TTCN_error("Could start docker container!");
	}

	log("Started docker container");
}

void ManoMsg::stopDockerContainer() {
	log("Stopping docker container");
	std::string cmd = "docker stop vim-emu > /dev/null";
	int status = std::system(cmd.c_str());

	if(status < 0) {
		TTCN_error("Could stop docker container!");
	}

	log("Stopped docker container");
}

void ManoMsg::setupCurl() {
	log("Setting up curl");
	curl = curl_easy_init();

	if(curl) {
	        // Setup curl options
	        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, replyToMemoryCallback);
	        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &replyBuffer);

	        chunk = nullptr;
	        chunk = curl_slist_append(chunk, "Accept: application/json");
	        chunk = curl_slist_append(chunk, "Content-Type: application/json");
	        chunk = curl_slist_append(chunk, "Expect:");
	        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);

	        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
	        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
	        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
	        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
	        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
	        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);

	        if(debug_http) {
	        	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
	        }

	        // authentication
	        curl_easy_setopt(curl, CURLOPT_USERNAME, rest_username.c_str());
	        curl_easy_setopt(curl, CURLOPT_PASSWORD, rest_password.c_str());
	} else {
		TTCN_error("Could not setup curl!");
	}

}

void ManoMsg::cleanCurl() {
	log("Cleaning up curl");
	curl_easy_cleanup(curl);
	curl_slist_free_all(chunk);
}

} /* end of namespace */

