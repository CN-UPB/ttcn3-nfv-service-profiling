// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for dark (dark@development) on Wed May 23 15:46:39 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "ManoMsg.hh"
#include <curl/curl.h>
#include <jsoncpp/json/json.h>
#include <iostream>
#include <string>
#include <fstream>
#include <streambuf>

namespace ServiceProfiling__PortType {

ManoMsg::ManoMsg(const char *par_port_name)
	: ManoMsg_BASE(par_port_name)
{
	debug = true;

	vnf_path = "/home/dark/vnfs/";
	nsd_path = "/home/dark/son-examples/service-projects/";

	rest_url = "http://172.17.0.2:5000";
	rest_username = "admin";
	rest_password = "admin";
}

ManoMsg::~ManoMsg()
{

}

void ManoMsg::set_parameter(const char * /*parameter_name*/,
	const char * /*parameter_value*/)
{

}

/*void ManoMsg::Handle_Fd_Event(int fd, boolean is_readable,
	boolean is_writable, boolean is_error) {}*/

void ManoMsg::Handle_Fd_Event_Error(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Writable(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Readable(int /*fd*/)
{

}

/*void ManoMsg::Handle_Timeout(double time_since_last_call) {}*/

void ManoMsg::user_map(const char * /*system_port*/)
{
	curl = curl_easy_init();

    if(curl) {
        // Setup curl options
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, replyToMemoryCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &replyBuffer);

        chunk = curl_slist_append(chunk, "Accept: application/json");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);
        curl_easy_setopt(curl, CURLOPT_HTTPPOST, 1L);

        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
        curl_easy_setopt(curl, CURLOPT_POST, 0L);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        //curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

        // authentication
        curl_easy_setopt(curl, CURLOPT_USERNAME, rest_username);
        curl_easy_setopt(curl, CURLOPT_PASSWORD, rest_password);

        // Test url if gatekeeper api is running
        setURL(rest_url + "/instantiations");

        performRestRequest();
    }

}

void ManoMsg::user_unmap(const char * /*system_port*/)
{
	curl_easy_cleanup(curl);
	curl_slist_free_all(chunk);
}

void ManoMsg::user_start()
{

}

void ManoMsg::user_stop()
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Setup__SFC& send_par)
{
	/* Onboard SFC */
	std::string service_name = std::string(((const char*)send_par.service__name()));
	std::string filepath = nsd_path + service_name;

	log("Create SFC from %s", filepath.c_str());

	setURL(rest_url + "/packages");

	curl_mime *mime = curl_mime_init(curl);
	curl_mimepart *part = curl_mime_addpart(mime);
	curl_mime_filedata(part, filepath.c_str());
	curl_mime_name(part, "package");

	curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);

	performRestRequest();
	curl_mime_free(mime);

	curl_easy_setopt(curl, CURLOPT_MIMEPOST, nullptr);

	/* Get service_uuid */
	/*Json::Value reply;
	Json::Reader reader;
	bool parseSucessful = reader.parse(replyBuffer.c_str(), reply);
	if(!parseSucessful) {
		TTCN_error("Could not parse reply from MANO system: %s\n", reader.getFormattedErrorMessages().c_str());
	}
	service_uuid = reply["service_uuid"].asString();
	log("Current service_uuid is %s", service_uuid.c_str());*/

	/* Start SFC */
	setURL(rest_url + "/instantiations");
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "{}");
	performRestRequest();

	log("SFC created and running");
}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Add__VNF& /*send_par*/)
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Start__CMD& /*send_par*/)
{

}

size_t ManoMsg::replyToMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

void ManoMsg::setURL(std::string url) {
	log("Next request to %s.", url.c_str());
	curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
}

void ManoMsg::performRestRequest() {
	log("Perform request");
	CURLcode res;

	/* We have to overwrite the last reply or the new reply from the server will be appended */
	replyBuffer = "";

	res = curl_easy_perform(curl);
	if(res != CURLE_OK) {
		TTCN_error("curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
	}

	log("replyBuffer: %s", replyBuffer.c_str());

	log("End perform request");
}

void ManoMsg::log(const char *fmt, ...) {
	if (debug) {
		va_list ap;
		va_start(ap, fmt);
		TTCN_Logger::begin_event(TTCN_DEBUG);
		TTCN_Logger::log_event("ManoMsg Test Port (%s): ", get_name());
		TTCN_Logger::log_event_va_list(fmt, ap);
		TTCN_Logger::end_event();
		va_end(ap);
	}
}

} /* end of namespace */

