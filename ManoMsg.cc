// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/6 R4A
// for dark (dark@development) on Wed May 23 15:46:39 2018

// Copyright (c) 2000-2018 Ericsson Telecom AB

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "ManoMsg.hh"
#include "yaml-cpp/yaml.h" // yaml-cpp >=0.6 needed
#include <iostream>
#include <string>
#include <fstream>
#include <streambuf>
#include <cstdlib>
#include <boost/algorithm/string.hpp>
#include <chrono>
#include <thread>
#include <cpprest/http_client.h>
#include <cpprest/filestream.h>

using namespace utility;
using namespace web;
using namespace web::http;
using namespace web::http::client;
using namespace concurrency::streams;

namespace ServiceProfiling__PortType {

ManoMsg::ManoMsg(const char *par_port_name)
	: ManoMsg_BASE(par_port_name)
{
	debug = true;
	debug_http = true;

	//vnf_path = "/home/dark/son-examples/service-projects/sonata-empty-service-emu/sources/vnf/";
	nsd_path = "/home/dark/son-examples/service-projects/";

	gatekeeper_rest_url = "http://172.17.0.2:5000";
	vimemu_rest_url = "http://172.17.0.2:5001";
	rest_username = "admin";
	rest_password = "admin";

	//sfc_service_instance_uuid = "";
	//sfc_service_uuid = "";
}

ManoMsg::~ManoMsg()
{

}

void ManoMsg::set_parameter(const char * /*parameter_name*/,
	const char * /*parameter_value*/)
{

}

/*void ManoMsg::Handle_Fd_Event(int fd, boolean is_readable,
	boolean is_writable, boolean is_error) {}*/

void ManoMsg::Handle_Fd_Event_Error(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Writable(int /*fd*/)
{

}

void ManoMsg::Handle_Fd_Event_Readable(int /*fd*/)
{

}

/*void ManoMsg::Handle_Timeout(double time_since_last_call) {}*/

void ManoMsg::user_map(const char * /*system_port*/)
{
	startDockerContainer();

	http_client client(gatekeeper_rest_url);
	auto query =  uri_builder("/instantiations").to_string();

	int retries = 5;
	bool rest_online = false;
	while(!rest_online) {
		try {
			http_response response = client.request(methods::GET, query).get();

			if(response.status_code() == status_codes::OK) {
				rest_online = true;
			}
		} catch (const http_exception &e) {
			log("Could connect to vim-emu: %s", e.what());
		}

		if(retries <= 0) {
			TTCN_error("Could connect to vim-emu!");
		} else if (!rest_online) {
			log("Retrying request");
			// wait 2 seconds if the request did not work
			std::this_thread::sleep_for(std::chrono::milliseconds(4000));
		}

		retries--;
	}
}

void ManoMsg::user_unmap(const char * /*system_port*/)
{
	stopAllVNF();

	if(!sfc_service_instance_uuid.empty() && !sfc_service_uuid.empty()) {
		stopSfcService(sfc_service_uuid, sfc_service_instance_uuid);
	}

	stopDockerContainer();
}

void ManoMsg::user_start()
{

}

void ManoMsg::user_stop()
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Setup__SFC& send_par)
{
	if(!sfc_service_instance_uuid.empty() && !sfc_service_uuid.empty()) {
		stopSfcService(sfc_service_uuid, sfc_service_instance_uuid);
	}

	std::string service_name = std::string(((const char*)send_par.service__name()));
	std::string filepath = nsd_path + service_name;

	log("Create SFC from %s", filepath.c_str());

	sfc_service_uuid = uploadPackage(filepath);
	// TODO: The following line is a hack. Sometimes the webserver is not fast enough
	std::this_thread::sleep_for(std::chrono::milliseconds(4000));
	sfc_service_instance_uuid = startSfcService(sfc_service_uuid);

	log("SFC created and running");
}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Add__VNF& send_par)
{
	std::string vnf_name = std::string(((const char*)send_par.name()));
	std::string vnf_cp = std::string(((const char*)send_par.connection__point()));
	std::string vnf_image = std::string(((const char*)send_par.image()));

	log("Setting up VNF %s with connection point %s from image %s", vnf_name.c_str(), vnf_cp.c_str(), vnf_image.c_str());

	startVNF(vnf_name, vnf_image);
	// TODO: The following line is a hack. Sometimes the webserver is not fast enough
	std::this_thread::sleep_for(std::chrono::milliseconds(4000));
	connectVnfToSfc(vnf_name, vnf_cp);
}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::Start__CMD& /*send_par*/)
{

}

void ManoMsg::outgoing_send(const ServiceProfiling__Types::ResourceConfiguration& send_par)
{
	std::string vnf_name = std::string(((const char*)send_par.function__id()));
	std::string memory_size = std::string(((const char*)send_par.max__mem()));
	std::string cpu_set = std::string(((const char*)send_par.cpu__set()));

	log("Setting resource configuration of VNF %s", vnf_name.c_str());

	// TODO: filename
	//std::string filename = nsd_path  + "sonata-empty-service-emu" + "/sources/vnf/" + vnf_name + "-vnfd.yml";
	std::string filename = "/home/dark/son-examples/service-projects/sonata-snort-service-emu/sources/vnf/snort-vnf/snort-vnfd.yml";

	log("Filename %s", filename.c_str());

	//YAML::Node root(YAML::LoadFile(filename));

	YAML::Node file = YAML::LoadFile(filename);

	file["virtual_deployment_units"][0]["resource_requirements"]["cpu"]["vcpus"] = 2; // TODO
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size"] = memory_size;
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size"] = "\"512\""; // TODO
	//file["virtual_deployment_units"][0]["resource_requirements"]["memory"]["size_unit"] = "\"MB\"";

	// Save the values as double qouted strings to the file
	std::ofstream fout(filename);
	YAML::Emitter em(fout);
	em.SetIndent(2);
	//em << file;


	//std::ofstream fout(filename);
	//fout << file;

	//std::system("son-package --project sonata-snort-service-emu -n sonata-snort-service");

	log("Setting resource configuration of VNF %s completed", vnf_name.c_str());
}

void ManoMsg::log(const char *fmt, ...) {
	if (debug) {
		va_list ap;
		va_start(ap, fmt);
		TTCN_Logger::begin_event(TTCN_DEBUG);
		TTCN_Logger::log_event("ManoMsg Test Port (%s): ", get_name());
		TTCN_Logger::log_event_va_list(fmt, ap);
		TTCN_Logger::end_event();
		va_end(ap);
	}
}

std::string ManoMsg::uploadPackage(std::string filepath) {
	log("Upload package from %s", filepath.c_str());

	auto fileStream = file_stream<unsigned char>::open_istream(filepath).get();
	fileStream.seek(0, std::ios::end);
	auto length = static_cast<size_t>(fileStream.tell());
	fileStream.seek(0, std::ios::beg);

	auto query =  uri_builder("/packages").to_string();
	http_request req(methods::POST);
	req.set_body(fileStream, length);
	req.set_request_uri(query);

	http_client client(gatekeeper_rest_url);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::Created) {
			auto json_reply = response.extract_json().get();
			auto service_uuid = json_reply.at("service_uuid").as_string();

			log("Uploaded package from %s as service_uuid %s", filepath.c_str(), service_uuid.c_str());

			return service_uuid;
		} else {
			TTCN_error("Could upload package to vim-emu. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could upload package to vim-emu: %s", e.what());
	}
}

std::string ManoMsg::startSfcService(std::string service_uuid) {
	log("Start SFC with uuid %s", service_uuid.c_str());

	json::value postParameters = web::json::value::object();
	postParameters["service_uuid"] = json::value::string(service_uuid);

	http_client client(gatekeeper_rest_url);
	auto query =  uri_builder("/instantiations").to_string();

	http_request req(methods::POST);
	req.set_request_uri(query);
	req.set_body(postParameters);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::Created) {
			auto json_reply = response.extract_json().get();
			auto service_instance_uuid = json_reply.at("service_instance_uuid").as_string();

			log("Started SFC as service_instance_uuid %s", service_instance_uuid.c_str());

			return service_instance_uuid;
		} else {
			TTCN_error("Could not start SFC. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could not start SFC: %s", e.what());
	}
}


void ManoMsg::stopSfcService(std::string service_uuid, std::string service_instance_uuid) {
	log("Stop service with uuid %s and instance uuid %s", service_uuid.c_str(), service_instance_uuid.c_str());

	json::value postParameters = web::json::value::object();
	postParameters["service_uuid"] = json::value::string(service_uuid);
	postParameters["service_instance_uuid"] = json::value::string(service_instance_uuid);

	http_client client(gatekeeper_rest_url);
	auto query =  uri_builder("/instantiations").to_string();

	http_request req(methods::DEL);
	req.set_request_uri(query);
	req.set_body(postParameters);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::OK) {
			log("Stopped service");
			return;
		} else {
			TTCN_error("Could not stop SFC. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could not stop SFC: %s", e.what());
	}

	log("Stopped service");
}

void ManoMsg::startVNF(std::string vnf_name, std::string vnf_image) {
	log("Start measurement point VNF with name %s from image %s", vnf_name.c_str(), vnf_image.c_str());

	json::value postParameters = web::json::value::object();
	postParameters["image"] = json::value::string(vnf_image);

	http_client client(vimemu_rest_url);
	auto query = uri_builder("/restapi/compute/dc1/" + vnf_name).to_string(); // TODO: dc1 configureable

	http_request req(methods::PUT);
	req.set_request_uri(query);
	req.set_body(postParameters);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::OK) {
			running_vnfs.push_back(vnf_name);
			log("Measurement point VNF %s created", vnf_name.c_str());

			return;
		} else {
			TTCN_error("Could not start Measurement point VNF. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could not start Measurement point VNF: %s", e.what());
	}
}

void ManoMsg::stopAllVNF() {
	log("Stopping all measurement point VNFs");

	for(std::string vnf_name : running_vnfs) {
		stopVNF(vnf_name);
	}

	running_vnfs.clear();
}

void ManoMsg::stopVNF(std::string vnf_name) {
	log("Stopping measurement point VNF %s", vnf_name.c_str());

	http_client client(vimemu_rest_url);
	auto query = uri_builder("/restapi/compute/dc1/" + vnf_name).to_string(); // TODO: dc1 configureable

	http_request req(methods::DEL);
	req.set_request_uri(query);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::OK) {
			//running_vnfs.push_back(vnf_name); TODO: Reverse operation (delete)
			log("Measurement point VNF %s stopped", vnf_name.c_str());

			return;
		} else {
			TTCN_error("Could not stop Measurement point VNF. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could not stop Measurement point VNF: %s", e.what());
	}
}

void ManoMsg::connectVnfToSfc(std::string vnf_name, std::string vnf_cp) {
	log("Connect %s to connection point %s", vnf_name.c_str(), vnf_cp.c_str());

	// TODO: Remove boost dependency (split function)
	std::vector<std::string> vnf_cp_elements;
	boost::split(vnf_cp_elements, vnf_cp, boost::is_any_of(":"));

	json::value postParameters = web::json::value::object();
	postParameters["vnf_src_name"] = json::value::string(vnf_name);
	postParameters["vnf_dst_name"] = json::value::string(vnf_cp_elements[0]);
	postParameters["vnf_src_interface"] = json::value::string(vnf_name + "-eth0");
	postParameters["vnf_dst_interface"] = json::value::string(vnf_cp_elements[1]);
	postParameters["bidirectional"] = json::value::string("True");
	postParameters["cookie"] = json::value::string("10");
	postParameters["priority"] = json::value::string("1000");


	http_client client(vimemu_rest_url);
	auto query = uri_builder("/restapi/network").to_string(); // TODO: dc1 configureable

	http_request req(methods::PUT);
	req.set_request_uri(query);
	req.set_body(postParameters);

	try {
		http_response response = client.request(req).get();

		if(response.status_code() == status_codes::OK) {
			log("Connected to connection point");

			return;
		} else {
			TTCN_error("Could not create Measurement point VNF. Status: %d", response.status_code());
		}
	} catch (const http_exception &e) {
		TTCN_error("Could not create Measurement point VNF: %s", e.what());
	}
}

void ManoMsg::startDockerContainer() {
	log("Starting docker container");

	std::string cmd = "docker run --name vim-emu -d --rm --privileged --pid='host' -v /var/run/docker.sock:/var/run/docker.sock vim-emu-img > /dev/null";
	int status = std::system(cmd.c_str());

	if(status < 0) {
		TTCN_error("Could start docker container!");
	}

	log("Started docker container");
}

void ManoMsg::stopDockerContainer() {
	log("Stopping docker container");
	std::string cmd = "docker stop vim-emu > /dev/null";
	int status = std::system(cmd.c_str());

	if(status < 0) {
		TTCN_error("Could stop docker container!");
	}

	log("Stopped docker container");
}

} /* end of namespace */

